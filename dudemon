#!/usr/bin/env python

try :
	import simplejson as json
except ImportError :
	import json

import traceback
import time
import os.path
import sys
import mediorc
import datediff
import dudeutils

class DudeCore(object) :
	WORK_DAY = 8 * 3600
	MUST_HAVE_ALREADY_LEFT = 24 * 3600

	def __init__(self, nick, statefile) :
		self.nick = nick
		self.statefile = statefile
		self.load()

	def read(self) :
		if os.path.exists(self.statefile) :
			fh = open(self.statefile, 'r')
			try :
				return json.load(fh)
			finally :
				fh.close()
		else :
			return {}

	def write(self, state) :
		if os.path.exists(self.statefile) :
			f = self.statefile + '.bak'
			os.rename(self.statefile, f)
		
		# TODO handle inability to write, or open, or close? Restore .bak file? What if that fails?
		fh = open(self.statefile, 'w')
		try :
			json.dump(state, fh)
		finally :
			fh.close()

	def load(self) :
		self.state = self.read()

	def dump(self) :
		self.write(self.state)

	def sanitize(self, nick) :
		lowchar = ''.join([c for c in nick.lower() if c in [chr(i + ord('a')) for i in range(26)]])
		if lowchar :
			return lowchar
		return nick

	def complain_nothere(self, now, who) :
		if not who in self.state or 'e' not in self.state[who] :
			return 'you never said you were here!'

		if now < self.state[who]['s'] :
			return 'you are not even here yet!'

		how_long = datediff.differ(now - self.state[who]['s'])
		
		if now > self.state[who]['e'] + DudeCore.MUST_HAVE_ALREADY_LEFT :
			return 'what, do you live here? That would mean you\'ve been here for %s' % how_long

	def handle(self, nick, text) :
		words = [w for w in text.split(' ') if w]
		who = self.sanitize(nick)

		chg = False
		cmds = ('!add', '!next', '!time', '!sched', '!here', '!bye', '!whom')
		stillhere_cmds = ['!stillhere', '!chilling']
		cmds = cmds + tuple(stillhere_cmds)

		try :
			now = int(time.time())

			if words and words[0] in cmds :
				cmd = words[0]

				if cmd == '!add' :
					self.state.setdefault(who, {})
					chg = True
					return 'ok, %s' % who
				elif cmd in ['!next', '!time'] :
					try :
						about = self.sanitize(words[1])
					except IndexError :
						about = who
					if about == self.nick :
						return "I should be here until the end of time"
					
					ud = self.state.get(about, dict()) # get user data
					if 's' in ud and 'e' in ud :
						s = ud['s']
						e = ud['e']
						if e < now :
							return '%s left about %s ago' % (about, datediff.differ(now - e))
						elif s > now :
							return '%s will get here in %s' % (about, datediff.differ(s - now))
						else :
							return '%s has been here for %s, should be here for another %s' % (about, datediff.differ(now - s), datediff.differ(e - now))
					else :
						return "sorry, I don't know when %s will be around" % about
				elif cmd == '!whom' :
					try :
						when = now + datediff.dur2sec(words[1])
					except IndexError :
						when = now
					except datediff.Bad :
						return 'usage: !whom [how_long_in_future] format is hours:minutes'

					return "As far as I know, %s" % dudeutils.whom(self.state, now, when)
				elif cmd == '!sched' :
					if who not in self.state :
						return 'sorry, you must !add yourself first'
					
					try :
						until_in = datediff.dur2sec(words[1])
						if (len(words) < 3) :
							dur_in = DudeCore.WORK_DAY
						else :
							dur_in = datediff.dur2sec(words[2])
					except IndexError :
						return 'usage: !sched <until_in> [duration_in] - formats are hours:minutes'
					except datediff.Bad :
						return 'usage: !sched <until_in> [duration_in] - formats are hours:minutes'

					when_in = now + until_in
					when_out = when_in + dur_in
					self.state[who]['u'] = now
					self.state[who]['s'] = when_in
					self.state[who]['e'] = when_out

					bump = dudeutils.overlap(self.state, self.state[who]['s'], self.state[who]['e'])
					if who in bump :
						bump.remove(who)

					if bump :
						append = '. You\'ll probably run into %s.' % dudeutils.oxford(bump)
					else :
						append = ''

					chg = True
					return 'See you for %s in %s, %s%s' % (datediff.differ(dur_in), datediff.differ(until_in), who, append)
				elif cmd == '!bye' :
					reason_failed = self.complain_nothere(now, who)
					if reason_failed is not None :
						return reason_failed

					how_long = datediff.differ(now - self.state[who]['s'])
					self.state[who]['e'] = now
					chg = True
					return 'bye, %s! You were here for %s' % (who, how_long)
				elif cmd in (['!here'] + stillhere_cmds) :
					if who not in self.state :
						return 'sorry, you must !add yourself first'

					still = cmd in stillhere_cmds

					try :
						dur_in = datediff.dur2sec(words[1])
					except IndexError :
						dur_in = None
					except datediff.Bad :
						return 'usage: !here [duration_in] - format is hours:minutes'

					if dur_in is None :
						if 's' in self.state[who] and 'e' in self.state[who] :
							dur_in = self.state[who]['e'] - self.state[who]['s']
						else :
							dur_in = DudeCore.WORK_DAY

						if still :
							return 'usage: !stillhere duration_in - format is hours:minutes'
					additional = None
					if not still and 'u' in self.state[who] and self.state[who]['u'] != self.state[who]['s'] :
						u = self.state[who]['u']
						s = self.state[who]['s']
						e = self.state[who]['e']

						# analyze how accurate the !sched prediction made was
						# expected diff, actual diff, and the diff between them
						e_d = s - u
						a_d = now - u
						d_d = e_d - a_d

						if abs(a_d) < abs(e - s) :
							if d_d > 0 :
								term = 'early'
							else :
								term = 'late'
							percent = 100 * (1.0 * abs(d_d) / abs(e_d))

							if d_d == 0 :
								additional = 'like clockwork'
							else :
								additional = '%s %s - a %0.1f%% error' % (datediff.differ(abs(d_d)), term, percent)

					if still :
						reason_failed = self.complain_nothere(now, who)
						if reason_failed is not None :
							return reason_failed
						additional_durst = 'another '
					else :
						additional_durst = ''

					self.state[who]['u'] = now
					if not still :
						self.state[who]['s'] = now
					self.state[who]['e'] = now + dur_in
					chg = True
					
					duration_statement = "I guess you'll be here for %s%s or so." % (additional_durst, datediff.differ(dur_in))

					if additional :
						return 'hello %s, you\'re %s. %s' % (who, additional, duration_statement)
					else :
						return 'hello, %s. %s' % (who, duration_statement)
		except :
			traceback.print_exc()
			return "You're raising exceptions, %s. Don't worry, I still like you." % who
		finally :
			if chg :
				self.dump()

class DudemonBot(mediorc.IRC) :
	def __init__(self, server, nick, chan, core) :
		self.core = core
		mediorc.IRC.__init__(self, server, nick, chan)
	
	def on_join(self, c, e) :
		self.initialize_pinger()

	def on_pubmsg(self, c, e) :
		nick = e.source().split("!")[0]
		chan = e.target()
		txt = e.arguments()[0]

		rmsg = self.core.handle(nick, txt)
		if rmsg :
			self.connection.privmsg(chan, rmsg)

class DudemonThread(mediorc.IRCThread) :
	def __init__(self, server, nick, chan, core) :
		self.bot_create = lambda: DudemonBot(server, nick, chan, core)
		mediorc.IRCThread.__init__(self)

if __name__ == '__main__' :
	try :
		server = sys.argv[1]
		nick = sys.argv[2]
		chan = sys.argv[3]
		statefile = sys.argv[4]

		core = DudeCore(nick, statefile)

		s = DudemonThread(server, nick, chan, core)
	except IndexError :
		print 'usage: dudemon <server> <nick> <channel> <statefile>'
		sys.exit(1)
	
	s.run()
